'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var deepMerge = require('../../dist/deepMerge-cb091110.cjs.dev.js');
var omick = require('../../dist/omick-042aa9a4.cjs.dev.js');
var string = require('../../dist/string-0759efb1.cjs.dev.js');
var cid = require('multiformats/cid');

// Arweave Protocol
const arweaveProtocolPattern = /^(ar):\/\/([^/?#]+)(.*)$/;

// Gateways
const pathGatewayPattern$1 = /^https:\/\/(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
const subdomainGatewayPattern$1 = /^https:\/\/([^/]+)\.(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;

/**
 * Takes an Arweave URL and returns a formatted Arweave URL if it is valid.
 * _This does not allow paths, query params, or hash in the URL and will return null_.
 * It does not check if the hash is a correct base64 URL encoded SHA-256 hash
 *
 * @param possibleArweaveString A possible URL for an Arweave resource. Can be a gateway or Arweave protocol URL.
 * @returns The formatted Arweave URI with `ar://` protocol and hash. Returns null if the URL is not valid.
 */
const parseArweaveTxId = possibleArweaveString => {
  if (!possibleArweaveString) {
    return null;
  }
  const arweaveProtocolHash = possibleArweaveString.match(arweaveProtocolPattern)?.[2];
  const arweaveProtocolUrlIndicators = possibleArweaveString.match(arweaveProtocolPattern)?.[3];
  if (arweaveProtocolHash) {
    return formatReturnHash(arweaveProtocolHash, arweaveProtocolUrlIndicators);
  }
  const subdomainGatewayHash = possibleArweaveString.match(subdomainGatewayPattern$1)?.[3];
  const subdomainGatewayUrlIndicators = possibleArweaveString.match(subdomainGatewayPattern$1)?.[4];
  if (subdomainGatewayHash) {
    return formatReturnHash(subdomainGatewayHash, subdomainGatewayUrlIndicators);
  }
  const pathGatewayHash = possibleArweaveString.match(pathGatewayPattern$1)?.[2];
  const pathGatewayUrlIndicators = possibleArweaveString.match(pathGatewayPattern$1)?.[3];
  if (pathGatewayHash) {
    return formatReturnHash(pathGatewayHash, pathGatewayUrlIndicators);
  }
  return null;
};
const formatReturnHash = (hash, urlIndicators) => {
  const hashWithUrlIndicators = `${hash}${urlIndicators ?? ''}`;
  return {
    url: `ar://${hashWithUrlIndicators}`,
    id: hashWithUrlIndicators
  };
};

// IPFS CID (naive check for lack of URL indicators)
const ipfsCidPattern = /^([^/?#]+)$/;

// IPFS Protocol
const ipfsProtocolPattern = /^(ipfs):\/\/([^/?#]+)(.*)$/;

// Gateways
const pathGatewayPattern = /^https?:\/\/[^/]+\/(ipfs)\/([^/?#]+)(.*)$/;
const subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ipfs)\.[^/?#]+(.*)$/;

/**
 * Takes an IPFS CID or URL and returns a formatted IPFS URL if the CID/URL is valid.
 * _This does not allow paths, query params, or hash in the URL and will return null_.
 *
 * @param possibleIpfsString A possible URL for an IPFS resource. Can be a gateway or IPFS protocol URL.
 * @returns The formatted IPFS URI with protocol and CID. Returns null if the URL is not valid.
 */
const parseCid = possibleIpfsString => {
  if (!possibleIpfsString) {
    return null;
  }
  const ipfsProtocolCid = possibleIpfsString.match(ipfsProtocolPattern)?.[2];
  const ipfsProtocolUrlIndicators = possibleIpfsString.match(ipfsProtocolPattern)?.[3];
  if (isCid(ipfsProtocolCid)) {
    return formatReturnCid(ipfsProtocolCid, ipfsProtocolUrlIndicators);
  }
  const subdomainGatewayCid = possibleIpfsString.match(subdomainGatewayPattern)?.[1];
  const subdomainGatewayUrlIndicators = possibleIpfsString.match(subdomainGatewayPattern)?.[3];
  if (isCid(subdomainGatewayCid)) {
    return formatReturnCid(subdomainGatewayCid, subdomainGatewayUrlIndicators);
  }
  const pathGatewayCid = possibleIpfsString.match(pathGatewayPattern)?.[2];
  const pathGatewayUrlIndicators = possibleIpfsString.match(pathGatewayPattern)?.[3];
  if (isCid(pathGatewayCid)) {
    return formatReturnCid(pathGatewayCid, pathGatewayUrlIndicators);
  }
  const ipfsCid = possibleIpfsString.match(ipfsCidPattern)?.[1];
  if (isCid(ipfsCid)) {
    return formatReturnCid(ipfsCid);
  }
  return null;
};
const isCid = hash => {
  try {
    if (!hash) {
      return false;
    }
    if (typeof hash === 'string') {
      return Boolean(cid.CID.parse(hash));
    }
    if (hash instanceof Uint8Array) {
      return Boolean(cid.CID.decode(hash));
    }
    return Boolean(cid.CID.asCID(hash));
  } catch {
    return false;
  }
};
const formatReturnCid = (cid, urlIndicators) => {
  const cidWithUrlIndicators = `${cid}${urlIndicators ?? ''}`;
  return {
    url: `ipfs://${cidWithUrlIndicators}`,
    id: cidWithUrlIndicators
  };
};

const noop = (..._args) => {
  //
};
const notEqual = (valueA, valueB) => {
  // This ensures (valueB==NaN, valueA==NaN) always returns false.
  return valueB !== valueA && (valueB === valueB || valueA === valueA);
};
const equal = (valueA, valueB) => {
  return !notEqual(valueA, valueB);
};
const isNull = value => {
  return value === null;
};
const isUndefined = value => {
  return typeof value === 'undefined';
};
const isNil = value => {
  return isNull(value) || isUndefined(value);
};
const isObject = value => {
  return value?.constructor === Object;
};
const isNumber = value => {
  return typeof value === 'number' && !Number.isNaN(value);
};
const isString = value => {
  return typeof value === 'string';
};
const isBoolean = value => {
  return typeof value === 'boolean';
};

// eslint-disable-next-line @typescript-eslint/ban-types
const isFunction = value => {
  return typeof value === 'function';
};
const isArray = value => {
  return Array.isArray(value);
};
const isWindow = value => {
  return value === window;
};

const cache = new Set();
function warn(message, id) {
  if (!cache.has(id ?? message)) {
    console.warn(message);
    cache.add(message);
  }
}

exports.deepMerge = deepMerge.deepMerge;
exports.omit = omick.omit;
exports.pick = omick.pick;
exports.b64Decode = string.b64Decode;
exports.b64Encode = string.b64Encode;
exports.b64UrlDecode = string.b64UrlDecode;
exports.b64UrlEncode = string.b64UrlEncode;
exports.equal = equal;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isFunction = isFunction;
exports.isNil = isNil;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.isUndefined = isUndefined;
exports.isWindow = isWindow;
exports.noop = noop;
exports.notEqual = notEqual;
exports.parseArweaveTxId = parseArweaveTxId;
exports.parseCid = parseCid;
exports.warn = warn;
