'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ms = require('ms');
var string = require('../../dist/string-7bb3bb00.cjs.prod.js');
var client = require('../../dist/client-b49d615d.cjs.prod.js');
var getStream = require('../../dist/getStream-03a26cdc.cjs.prod.js');
require('zustand/middleware');
require('zustand/vanilla');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ms__default = /*#__PURE__*/_interopDefault(ms);

const getSubtleCrypto = async () => {
  if (typeof window !== 'undefined') {
    if (window?.crypto?.subtle) {
      return window.crypto.subtle;
    }
    throw new Error('Browser is not in a secure context (HTTPS), cannot use SubtleCrypto: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto');
  } else {
    const crypto = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('node:crypto')); });
    return crypto.webcrypto.subtle;
  }
};

const signEcdsaSha256 = async (privateKey, data) => {
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.sign({
    name: 'ECDSA',
    hash: {
      name: 'SHA-256'
    }
  }, privateKey, data);
};

const importPKCS8 = async pkcs8 => {
  if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
    throw new TypeError('"pkcs8" must be PKCS8 formatted string');
  }
  const privateKeyContents = string.b64UrlDecode(pkcs8.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''));
  if (!privateKeyContents) {
    throw new TypeError('Could not base64 decode private key contents.');
  }
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.importKey('pkcs8', new Uint8Array(privateKeyContents?.split('').map(c => c.charCodeAt(0))), {
    name: 'ECDSA',
    namedCurve: 'P-256'
  }, false, ['sign']);
};

/**
 * Signs a JSON Web Token which can be used to view access-restricted media. If you have not instantiated a client yet,
 * will throw a "No livepeer client found." error if no `config` is passed.
 *
 * Throws if there is an error fetching a stream by ID.
 */
const signAccessJwt = async (options, config) => {
  // assume strings passed are PEM-encoded PKCS8 (or base64 encoded)
  // try to coerce the input from base64, or use as-is
  const privateKey = typeof options.privateKey === 'string' ? await importPKCS8(string.b64Decode(options.privateKey) ?? options.privateKey) : options.privateKey;
  if (!privateKey) {
    throw new Error('Error importing private key.');
  }
  let playbackId = options?.playbackId;
  if (options?.streamId) {
    if (config) {
      client.createClient(config);
    }
    const stream = await getStream.getStream({
      streamId: options.streamId
    });
    playbackId = stream.playbackId;
  }
  if (!playbackId) {
    throw new Error('Playback ID was not provided and stream playback ID could not be fetched.');
  }
  const issuedAtSec = Date.now() / 1000;
  const expirationSec = issuedAtSec + ms__default["default"](options.expiration ?? '1d') / 1000;
  const payload = {
    action: 'pull',
    iss: options.issuer,
    pub: options.publicKey,
    sub: playbackId,
    video: 'none',
    exp: Number(expirationSec.toFixed(0)),
    iat: Number(issuedAtSec.toFixed(0)),
    ...(options.custom ? {
      custom: {
        ...options.custom
      }
    } : {})
  };
  const header = {
    alg: 'ES256',
    typ: 'JWT'
  };
  const base64Header = string.b64UrlEncode(JSON.stringify(header));
  const base64Payload = string.b64UrlEncode(JSON.stringify(payload));
  const body = `${base64Header}.${base64Payload}`;
  const signatureBuffer = await signEcdsaSha256(privateKey, Buffer.from(body));
  const signature = string.b64UrlEncode(String.fromCharCode(...new Uint8Array(signatureBuffer)));
  return `${base64Header}.${base64Payload}.${signature}`;
};

exports.importPKCS8 = importPKCS8;
exports.signAccessJwt = signAccessJwt;
